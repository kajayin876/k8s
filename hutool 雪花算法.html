<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.7.24 (476601)"/><meta name="author" content="k1mcu740"/><meta name="created" content="2023-01-02 06:57:30 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2023-01-02 07:00:29 +0000"/><title>hutool 雪花算法</title></head><body><h1 style="font-size: 20pt; line-height: 1.45; text-align: left; text-indent: 0;"><span style="font-size: 20pt; line-height: 1.45; text-indent: 0; font-weight: bold; color: rgb(0, 0, 0); font-family: Lato, Lato, Lato, Lato;">1.概述</span></h1><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(0, 0, 0); font-size: 12pt; font-family: Lato, Lato, Lato, Lato;-en-paragraph:true;">分布式系统中，有一些需要使用全局唯一ID的场景，这种时候为了防止ID冲突可以使用32位的UUID，但是UUID有一些缺点，首先他相对比较长，另外UUID一般是无序的。</span></div><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(0, 0, 0); font-size: 12pt; font-family: Lato, Lato, Lato, Lato;-en-paragraph:true;">有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。</span></div><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(0, 0, 0); font-size: 12pt; font-family: Lato, Lato, Lato, Lato;-en-paragraph:true;">而twitter的snowflake解决了这种需求，最初Twitter把存储系统从MySQL迁移到Cassandra，因为Cassandra没有顺序ID生成机制，所以开发了这样一套全局唯一ID生成服务。</span></div><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(0, 0, 0); font-size: 12pt; font-family: Lato, Lato, Lato, Lato;-en-paragraph:true;"> </span></div><h1 style="font-size: 20pt; line-height: 1.45; text-align: left; text-indent: 0;"><span style="font-family: Lato, Lato, Lato, Lato; font-size: 12pt;"> </span><br/></h1><h1 style="font-size: 20pt; line-height: 1.45; text-align: left; text-indent: 0;"><span style="font-size: 20pt; line-height: 1.45; text-indent: 0; font-weight: bold; color: rgb(0, 0, 0); font-family: Lato, Lato, Lato, Lato;">2.源码</span></h1><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px; color: rgb(0, 0, 0); font-size: 12pt; font-family: Lato, Lato, Lato, Lato;-en-paragraph:true;">hutool版本的源码</span></div><div>package cn.hutool.core.lang;</div><div><br/></div><div>import cn.hutool.core.date.SystemClock;</div><div>import cn.hutool.core.util.StrUtil;</div><div><br/></div><div>import java.io.Serializable;</div><div>import java.util.Date;</div><div><br/></div><div>/**</div><div> * Twitter的Snowflake 算法&lt;br&gt;</div><div> * 分布式系统中，有一些需要使用全局唯一ID的场景，有些时候我们希望能使用一种简单一些的ID，并且希望ID能够按照时间有序生成。</div><div> *</div><div> * &lt;p&gt;</div><div> * snowflake的结构如下(每部分用-分开):&lt;br&gt;</div><div> *</div><div> * &lt;pre&gt;</div><div> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</div><div> * &lt;/pre&gt;</div><div> * &lt;p&gt;</div><div> * 第一位为未使用(符号位表示正数)，接下来的41位为毫秒级时间(41位的长度可以使用69年)&lt;br&gt;</div><div> * 然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点）&lt;br&gt;</div><div> * 最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）</div><div> * &lt;p&gt;</div><div> * 并且可以通过生成的id反推出生成时间,datacenterId和workerId</div><div> * &lt;p&gt;</div><div> * 参考：<a href="http://www">http://www</a>.<a href="http://cnblogs.com/relucent/p/4955340.html">cnblogs.com/relucent/p/4955340.html</a></div><div> *</div><div> * @author Looly</div><div> * @since 3.0.1</div><div> */</div><div>public class Snowflake implements Serializable {</div><div>        private static final long serialVersionUID = 1L;</div><div><br/></div><div>        private final long twepoch;</div><div>        private final long workerIdBits = 5L;</div><div>        private final long dataCenterIdBits = 5L;</div><div>        //// 最大支持机器节点数0~31，一共32个</div><div>        // 最大支持数据中心节点数0~31，一共32个</div><div>        @SuppressWarnings({"PointlessBitwiseExpression", "FieldCanBeLocal"})</div><div>        private final long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);</div><div>        @SuppressWarnings({"PointlessBitwiseExpression", "FieldCanBeLocal"})</div><div>        private final long maxDataCenterId = -1L ^ (-1L &lt;&lt; dataCenterIdBits);</div><div>        // 序列号12位</div><div>        private final long sequenceBits = 12L;</div><div>        // 机器节点左移12位</div><div>        private final long workerIdShift = sequenceBits;</div><div>        // 数据中心节点左移17位</div><div>        private final long dataCenterIdShift = sequenceBits + workerIdBits;</div><div>        // 时间毫秒数左移22位</div><div>        private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits;</div><div>        @SuppressWarnings({"PointlessBitwiseExpression", "FieldCanBeLocal"})</div><div>        private final long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);// 4095</div><div><br/></div><div>        private final long workerId;</div><div>        private final long dataCenterId;</div><div>        private final boolean useSystemClock;</div><div>        private long sequence = 0L;</div><div>        private long lastTimestamp = -1L;</div><div><br/></div><div>        /**</div><div>         * 构造</div><div>         *</div><div>         * @param workerId     终端ID</div><div>         * @param dataCenterId 数据中心ID</div><div>         */</div><div>        public Snowflake(long workerId, long dataCenterId) {</div><div>                this(workerId, dataCenterId, false);</div><div>        }</div><div><br/></div><div>        /**</div><div>         * 构造</div><div>         *</div><div>         * @param workerId         终端ID</div><div>         * @param dataCenterId     数据中心ID</div><div>         * @param isUseSystemClock 是否使用{@link SystemClock} 获取当前时间戳</div><div>         */</div><div>        public Snowflake(long workerId, long dataCenterId, boolean isUseSystemClock) {</div><div>                this(null, workerId, dataCenterId, isUseSystemClock);</div><div>        }</div><div><br/></div><div>        /**</div><div>         * @param epochDate        初始化时间起点（null表示默认起始日期）,后期修改会导致id重复,如果要修改连workerId dataCenterId，慎用</div><div>         * @param workerId         工作机器节点id</div><div>         * @param dataCenterId     数据中心id</div><div>         * @param isUseSystemClock 是否使用{@link SystemClock} 获取当前时间戳</div><div>         * @since 5.1.3</div><div>         */</div><div>        public Snowflake(Date epochDate, long workerId, long dataCenterId, boolean isUseSystemClock) {</div><div>                if (null != epochDate) {</div><div>                        this.twepoch = epochDate.getTime();</div><div>                } else{</div><div>                        // Thu, 04 Nov 2010 01:42:54 GMT</div><div>                        this.twepoch = 1288834974657L;</div><div>                }</div><div>                if (workerId &gt; maxWorkerId || workerId &lt; 0) {</div><div>                        throw new IllegalArgumentException(StrUtil.format("worker Id can't be greater than {} or less than 0", maxWorkerId));</div><div>                }</div><div>                if (dataCenterId &gt; maxDataCenterId || dataCenterId &lt; 0) {</div><div>                        throw new IllegalArgumentException(StrUtil.format("datacenter Id can't be greater than {} or less than 0", maxDataCenterId));</div><div>                }</div><div>                this.workerId = workerId;</div><div>                this.dataCenterId = dataCenterId;</div><div>                this.useSystemClock = isUseSystemClock;</div><div>        }</div><div><br/></div><div>        /**</div><div>         * 根据Snowflake的ID，获取机器id</div><div>         *</div><div>         * @param id snowflake算法生成的id</div><div>         * @return 所属机器的id</div><div>         */</div><div>        public long getWorkerId(long id) {</div><div>                return id &gt;&gt; workerIdShift &amp; ~(-1L &lt;&lt; workerIdBits);</div><div>        }</div><div><br/></div><div>        /**</div><div>         * 根据Snowflake的ID，获取数据中心id</div><div>         *</div><div>         * @param id snowflake算法生成的id</div><div>         * @return 所属数据中心</div><div>         */</div><div>        public long getDataCenterId(long id) {</div><div>                return id &gt;&gt; dataCenterIdShift &amp; ~(-1L &lt;&lt; dataCenterIdBits);</div><div>        }</div><div><br/></div><div>        /**</div><div>         * 根据Snowflake的ID，获取生成时间</div><div>         *</div><div>         * @param id snowflake算法生成的id</div><div>         * @return 生成的时间</div><div>         */</div><div>        public long getGenerateDateTime(long id) {</div><div>                return (id &gt;&gt; timestampLeftShift &amp; ~(-1L &lt;&lt; 41L)) + twepoch;</div><div>        }</div><div><br/></div><div>        /**</div><div>         * 下一个ID</div><div>         *</div><div>         * @return ID</div><div>         */</div><div>        public synchronized long nextId() {</div><div>                long timestamp = genTime();</div><div>                if (timestamp &lt; lastTimestamp) {</div><div>                        if(lastTimestamp - timestamp &lt; 2000){</div><div>                                // 容忍2秒内的回拨，避免NTP校时造成的异常</div><div>                                timestamp = lastTimestamp;</div><div>                        } else{</div><div>                                // 如果服务器时间有问题(时钟后退) 报错。</div><div>                                throw new IllegalStateException(StrUtil.format("Clock moved backwards. Refusing to generate id for {}ms", lastTimestamp - timestamp));</div><div>                        }</div><div>                }</div><div><br/></div><div>                if (timestamp == lastTimestamp) {</div><div>                        sequence = (sequence + 1) &amp; sequenceMask;</div><div>                        if (sequence == 0) {</div><div>                                timestamp = tilNextMillis(lastTimestamp);</div><div>                        }</div><div>                } else {</div><div>                        sequence = 0L;</div><div>                }</div><div><br/></div><div>                lastTimestamp = timestamp;</div><div><br/></div><div>                return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (dataCenterId &lt;&lt; dataCenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence;</div><div>        }</div><div><br/></div><div>        /**</div><div>         * 下一个ID（字符串形式）</div><div>         *</div><div>         * @return ID 字符串形式</div><div>         */</div><div>        public String nextIdStr() {</div><div>                return Long.toString(nextId());</div><div>        }</div><div><br/></div><div>        // ------------------------------------------------------------------------------------------------------------------------------------ Private method start</div><div><br/></div><div>        /**</div><div>         * 循环等待下一个时间</div><div>         *</div><div>         * @param lastTimestamp 上次记录的时间</div><div>         * @return 下一个时间</div><div>         */</div><div>        private long tilNextMillis(long lastTimestamp) {</div><div>                long timestamp = genTime();</div><div>                // 循环直到操作系统时间戳变化</div><div>                while (timestamp == lastTimestamp) {</div><div>                        timestamp = genTime();</div><div>                }</div><div>                if (timestamp &lt; lastTimestamp) {</div><div>                        // 如果发现新的时间戳比上次记录的时间戳数值小，说明操作系统时间发生了倒退，报错</div><div>                        throw new IllegalStateException(</div><div>                                        StrUtil.format("Clock moved backwards. Refusing to generate id for {}ms", lastTimestamp - timestamp));</div><div>                }</div><div>                return timestamp;</div><div>        }</div><div><br/></div><div>        /**</div><div>         * 生成时间戳</div><div>         *</div><div>         * @return 时间戳</div><div>         */</div><div>        private long genTime() {</div><div>                return this.useSystemClock ? SystemClock.now() : System.currentTimeMillis();</div><div>        }</div><div>        // ------------------------------------------------------------------------------------------------------------------------------------ Private method end</div><div>}</div><h2 style="font-size: 16pt; line-height: 85%; text-align: left; text-indent: 0;"><span style="font-size: 16pt; line-height: 85%; text-indent: 0; font-weight: bold;">3 时间回拨：</span></h2><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">hutool版本只能容忍2秒回拨误差，超过2秒回拨会抛出异常</span></div><h2 style="font-size: 16pt; line-height: 85%; text-align: left; text-indent: 0;"><span style="font-size: 16pt; line-height: 85%; text-indent: 0; font-weight: bold;">4 workId设置方案</span></h2><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">1.获取kubernetes docker 镜像ip地址，进行逻辑运算生成dataCenterId和workId。只能降低重复概率</span></div></body></html>