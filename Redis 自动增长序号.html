<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.7.24 (476601)"/><meta name="author" content="k1mcu740"/><meta name="created" content="2023-01-01 11:34:36 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2023-01-02 07:06:24 +0000"/><title>Redis 自动增长序号</title></head><body><h1 style="font-size: 20pt; text-align: left; text-indent: 0px;"><span style="font-size: 20pt; text-indent: 0px; letter-spacing: -0.0165pt; color: rgb(41, 41, 41); font-family: charter, charter, charter, charter; font-weight: bold; line-height: 22.666664px;">1.背景</span></h1><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">由于现在有太多从小到大的系统需要唯一的全局标识符，这是分布式计算中需要立即解决的一项重要任务。</span></div><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">许多系统现在需要唯一的全球标识符，例如社会号码、银行帐号等。</span></div><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">通常，可以使用在每次调用时增加的共享计数器来简单地实现 ID 生成器。另一个本地解决方案是生成一个作为时间戳函数的 ID。但这些都是不好的解决方案，因为存在以下问题。</span></div><ol style="list-style-type: decimal;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">多个独立的服务器可以生成相同的 ID。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">两个连续的请求将生成相同的 ID。</span></div></li></ol><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><span style="font-size: 16pt; text-indent: 0px; color: rgb(41, 41, 41); font-family: sohne, sohne, sohne, sohne; font-weight: bold; line-height: 18.133333px;">1.1 .目标</span></h2><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">分布式 ID 生成器必须满足以下要求。</span></div><ol style="list-style-type: lower-alpha;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">解决数据库主键id</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">ID 生成器应在整个集群中按顺序生成唯一 ID。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">能够每秒生成超过 10000个 ID。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">统一产研团队数据库主键id</span></div></li></ol><h1 style="font-size: 20pt; text-align: left; text-indent: 0px;"><span style="font-size: 20pt; text-indent: 0px; color: rgb(41, 41, 41); font-family: sohne, sohne, sohne, sohne; font-weight: bold; line-height: 22.666664px;">2 . </span><span style="font-size: 20pt; text-indent: 0px; color: rgb(41, 41, 41); font-family: sohne, sohne, sohne, sohne; font-weight: bold; line-height: 22.666664px;">技术选型</span></h1><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><span style="font-size: 16pt; text-indent: 0px; font-weight: bold; line-height: 18.133333px;">2.1 UUID</span></h2><h3 style="font-size: 14pt; text-align: left; text-indent: 0px;"><span style="font-size: 14pt; text-indent: 0px; font-weight: bold; line-height: 15.866666px;">2.1.1 方案：</span></h3><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">通用唯一标识符是一个众所周知的概念，多年来一直在软件中使用。UUID 是全球唯一的 128 位十六进制数字。UUID 有四个版本。</span></div><ol style="list-style-type: lower-alpha;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">UUID1 使用 MAC 地址和时间戳来生成有效的唯一性。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">UUID3 和 UUID 5 使用加密散列和应用程序提供的文本字符串来生成 UUID。（UUID 3 使用 MD5 散列，UUID 5 使用 SHA-1 散列）</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">UUID4 使用伪随机数生成器来生成 UUID。</span></div></li></ol><h3 style="font-size: 14pt; text-align: left; text-indent: 0px;"><span style="font-size: 14pt; text-indent: 0px; font-weight: bold; line-height: 15.866666px;">2.1.2</span><span style="font-size: 14pt; text-indent: 0px; line-height: 15.866666px;"> uuid 优点和缺点：</span></h3><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">优点：</span></div><ol style="list-style-type: decimal;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">有效独特，极少出现重复。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">任何服务器都可以独立生成唯一 ID，无需任何协调。</span></div></li></ol><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">缺点</span></div><ol style="list-style-type: lower-alpha;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">生成的 ID 没有排序。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">它们很大且索引复杂</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">对于某些用例来说，128 位的 ID 可能太大了。浪费数据库存储</span></div></li></ol><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><span style="font-size: 16pt; text-indent: 0px; color: rgb(41, 41, 41); font-family: sohne, sohne, sohne, sohne; font-weight: bold; line-height: 18.133333px;">2.2 MySQL</span></h2><h3 style="font-size: 14pt; text-align: left; text-indent: 0px;"><span style="font-size: 14pt; text-indent: 0px; font-weight: bold; line-height: 15.866666px;">2.2.1 方案：</span></h3><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">MySQL 使用 AUTO_INCREMENT 生成 ID ，单独用一张表存放id自动增长</span></div><h3 style="font-size: 14pt; text-align: left; text-indent: 0px;"><span style="font-size: 14pt; text-indent: 0px; font-weight: bold; line-height: 15.866666px;">2.2.2 优点和缺点</span></h3><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">优点</span></div><ol style="list-style-type: decimal;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">保证排序和唯一性。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">使用数据库生成的简单性。</span></div></li></ol><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">缺点</span></div><ol style="list-style-type: decimal;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">由于只有一个实例，因此无法水平扩展。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">不能容错，因为您只有一个实例来生成 ID。</span></div></li></ol><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><span style="font-size: 16pt; text-indent: 0px; font-weight: bold; line-height: 18.133333px;">2.3 MongoDB</span></h2><h3 style="font-size: 14pt; text-align: left; text-indent: 0px;"><span style="font-size: 14pt; text-indent: 0px; font-weight: bold; line-height: 15.866666px;">2.3.1 方案</span></h3><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">MongoDB 使用 ObjectIds 作为每个文档的 _id 字段的默认值，该字段在创建任何文档时生成。</span></div><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">MongoDB 对象 ID 是 12 字节（96 位）的十六进制整数，以随机值开头，由 4 字节的纪元时间戳（以秒为单位）、3 字节的机器标识、2 字节的进程 ID 和 3-字节计数器。</span></div><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">这是一个比之前的 128 位版本更小的 UUID。但是，大小比我们通常在单个 MySQL 自动增量列（64 位数字值）中找到的要大。</span></div><h3 style="font-size: 14pt; text-align: left; text-indent: 0px;"><span style="font-size: 14pt; text-indent: 0px; font-weight: bold; line-height: 15.866666px;">2.3.2 优点</span></h3><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">优点:</span></div><ol style="list-style-type: decimal;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">每个应用程序线程单独创建 ID，从而减少 ID 创建失败点和争用。如果 ID 的第一个组件是时间戳，则 ID 保持时间可排序。</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">为了建立足够的唯一性保证，通常需要额外的存储空间（96 位或更多）。一些 UUID 类型没有自然顺序并且是随机的。</span></div></li></ol><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><br/></h2><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><span style="font-size: 16pt; text-indent: 0px; line-height: 18.133333px;">2.6 Redis 自动增长序号</span></h2><div style="text-align: left; text-indent: 0px; margin-top: 1em; margin-bottom: 1em;"><span style="text-indent: 0px;-en-paragraph:true;">介绍 </span><span style="text-indent: 0px; font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, -apple-system, -apple-system, -apple-system;-en-paragraph:true;">Redis实现分布式唯一ID主要是通过提供像 </span><span style="text-indent: 0px; font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, -apple-system, -apple-system, -apple-system; font-style: italic;-en-paragraph:true;">INCR</span><span style="text-indent: 0px; font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, -apple-system, -apple-system, -apple-system;-en-paragraph:true;"> 和 </span><span style="text-indent: 0px; font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, -apple-system, -apple-system, -apple-system; font-style: italic;-en-paragraph:true;">INCRBY</span><span style="text-indent: 0px; font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, -apple-system, -apple-system, -apple-system;-en-paragraph:true;"> 这样的自增原子命令，由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。 id是递增模式</span></div><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><span style="font-size: 16pt; text-indent: 0px; color: rgb(36, 41, 47); font-family: -apple-system, -apple-system, -apple-system, -apple-system; font-weight: bold; line-height: 18.133333px;">2.6.1 优点</span></h2><ol style="list-style-type: decimal;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">可以保证原子性，绝对不会出现重复id 且id是递增模式</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px;">高并发低延迟</span></div></li></ol><h3 style="font-size: 14pt; text-align: left; text-indent: 0px;"><span style="font-size: 14pt; text-indent: 0px; font-weight: bold; line-height: 15.866666px;">2.6.2 缺点</span></h3><ol style="list-style-type: decimal;"><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px; font-size: 12pt; color: rgb(36, 41, 47); font-family: -apple-system, -apple-system, -apple-system, -apple-system;">无法水平扩展（因为做集群部署会有数据同步问题） 容错性比较低</span></div></li><li><div style="text-align: left; text-indent: 0px;"><span style="text-indent: 0px; font-size: 12pt; color: rgb(36, 41, 47); font-family: -apple-system, -apple-system, -apple-system, -apple-system;">工程需要对redis做集成</span></div></li></ol><h2 style="font-size: 16pt; text-align: left; text-indent: 0px;"><br/></h2></body></html>