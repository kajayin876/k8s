<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.7.24 (476601)"/><meta name="author" content="k1mcu740"/><meta name="created" content="2023-01-02 06:50:28 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2023-01-02 06:56:15 +0000"/><title>雪花算法定义</title></head><body><div style="line-height: 1.4em; font-family: Roboto, sans-serif; color: rgb(0, 51, 153); font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(254, 254, 254); margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 1.4em; font-family: Roboto, sans-serif; color: rgb(0, 51, 153); font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(254, 254, 254); font-weight: bold;-en-paragraph:true;"><font style="font-size: 24px;">1.什么是雪花？</font></span><br/></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><span style="-en-paragraph:true;">在以前的项目中，最常见的两种主键类型是自增Id和UUID，在比较这两种ID之前首先要搞明白一个问题，就是为什么主键有序比无序查询效率要快，因为自增Id和UUID之间最大的不同点就在于有序性。
</span></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><span style="-en-paragraph:true;">我们都知道，当我们定义了主键时，数据库会选择表的主键作为聚集索引(B+Tree)，mysql 在底层是以数据页为单位来存储数据的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><span style="-en-paragraph:true;">也就是说如果主键为</span><span style="-en-paragraph:true;">自增 id</span><span style="-en-paragraph:true;"> 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。</span><span style="font-weight: bold;-en-paragraph:true;">如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据</span><span style="-en-paragraph:true;">。如果主键是</span><span style="-en-paragraph:true;">UUID</span><span style="-en-paragraph:true;">，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。</span><span style="font-weight: bold;-en-paragraph:true;">这就造成了页分裂，这个大量移动数据的过程是会严重影响插入效率的</span><span style="-en-paragraph:true;">。
</span></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><span style="-en-paragraph:true;">一句话总结就是，InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。
</span></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><span style="-en-paragraph:true;">但是为什么很多情况又不用</span><span style="-en-paragraph:true;">自增id</span><span style="-en-paragraph:true;">作为主键呢？
</span></div><ul style="text-align: start;"><li><div>容易导致主键重复。比如导入旧数据时，线上又有新的数据新增，这时就有可能在导入时发生主键重复的异常。为了避免导入数据时出现主键重复的情况，要选择在应用停业后导入旧数据，导入完成后再启动应用。显然这样会造成不必要的麻烦。而UUID作为主键就不用担心这种情况。</div></li><li><div>不利于数据库的扩展。当采用自增id时，分库分表也会有主键重复的问题。UUID则不用担心这种问题。</div></li></ul><div><br/></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><span style="-en-paragraph:true;">snowflake是Twitter开源的分布式ID生成算法，结果是64bit的Long类型的ID，有着全局唯一和有序递增的特点。
</span></div><div style="margin-top: 1em; margin-bottom: 1em; text-align: start;"><a href="%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%AE%9A%E4%B9%89.resources/DAB945BC-B16C-4899-9C07-B8F83C70D8F7.webp">DAB945BC-B16C-4899-9C07-B8F83C70D8F7.webp</a></div><ul style="text-align: start;"><li><div>最高位是符号位，因为生成的 ID 总是正数，始终为0，不可用。</div></li><li><div>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</div></li><li><div>10位的机器标识，10位的长度最多支持部署1024个节点。</div></li><li><div>12位的计数序列号，序列号即一系列的自增ID，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</div></li></ul><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div></body></html>